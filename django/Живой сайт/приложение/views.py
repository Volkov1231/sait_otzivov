import os
from django.shortcuts import render, get_object_or_404, redirect

from .models import *
from .forms import *

def домашняя(реквест):
    # Все функции в том файле принимают обязательный аргумент, его принято называть реквест 
    
    # Функция render отправляет страницу в процесс сброки, чтобы она отобразилась

    посты = Отзыв.objects.all()
    контекст = {
        "посты": посты,
        "надо_показывать_кнопку_читать_полностью": True,
    }
    return render(реквест, "главная.html", контекст)

def один_отзыв(реквест, айди_отзыва):
    отзыв = get_object_or_404(Отзыв, id=айди_отзыва)
    #  Функция get_object_or_404 либо возвращает одну запись из таблицы Отзыв,  либо, если отзыва с таким айди не существует, вызывает  ошибку 404 (страница не найдена)
    # тк она должна вернуть, ОДИН объект, вторым аргументом указываем название поля, по которму ищем запись,а после = значение по которому фильтруемся. Например, если переменная айди_отзыва будет равноа 1, то вернётся отзыв с id=1

    контекст = {"посты": [отзыв]}
    return render(реквест, "главная.html", контекст)

def фильтрация_по_тегу(реквест, имя_тега):
    искомый_тег = get_object_or_404(Тег, текст=имя_тега)
    # получили запись из таблицы Тег, и дальше отфильтруем все отзывы, которые связаны с этим тегом

    # для этого получаем список всех отзывов и применяем к ним функцию filter
    посты = Отзыв.objects.all()
    отфильтрованные_посты = посты.filter(тег=искомый_тег)
    # в скобках filter указываем название поля, после равно запись тега, которую получили выше
    контекст = {
        "посты": отфильтрованные_посты,
        "надо_показывать_кнопку_читать_полностью": True,
    }
    return render(реквест, "главная.html", контекст)

def фильтрация_по_автору(реквест, айди_автора):
    искомый_автор = get_object_or_404(Юзер, id=айди_автора)
    посты = Отзыв.objects.all()
    отфильтрованные_посты = посты.filter(автор=искомый_автор)
    контекст = {
        "посты": отфильтрованные_посты,
        "надо_показывать_кнопку_читать_полностью": True,
    }
    return render(реквест, "главная.html", контекст)

def создать_отзыв(реквест):
    # Для корректировки или созлдания объектов  в бд (такие как отзыв), необходимо использовать ФОРМЫ. ОНи встроены в джанго, связываются с моделью, их поля отображаются в ХТМЛ. По завершении написания отзыва форма автоматически проверяет корректность данных (она не ползволит в int-поле ввести текст или вместо картинки загрузить видео) 

    # Формы создаются в файле forms.py, импортируются во views.py

    # У каждой формы есть два действия:
    # 1. Показ формы юзеру, чтобы он заполнил её
    # 2. Проверка заполненной информации и сохранение её в БД

    # За оба действия отвечает одна функция. Они разделяются по http-методу GET - получение или POST - отправка

    # GET - это значит пользователь открыл страницу
    # POST - когда он нажал кнопку "сохранить"

    # Информация о http-методе находится в переменной "реквест"

    if реквест.method == "GET":
        форма = ФормаОтзыва()
        контекст = {"форма": форма}
        return render(реквест, "редактировать_отзыв.html", контекст)
    
    # Сейчас был отправлен метод POST, в переменной "реквест" хранится вся информация от пользователя, в том числе файлы
    # Передаём эту информацию в формы, чтогбы прошла проверка на корректность введённых данных
    заполнения_форма = ФормаОтзыва(реквест.POST, реквест.FILES)

    # корректность данных = "валидность" формы
    if заполнения_форма.is_valid():
        # Если все данные валидны
        # Надо превратить форму в объект БД, но если его сразу сохранить, база ответит ошибкой - нет информации об авторе (в форме она не предполагалась)
        новый_отзыв = заполнения_форма.save(commit=False)
        # commit=False не позволяет создать запись в БД
        новый_отзыв.автор = реквест.user
        # автором будет тот юзер, который залогинен
        новый_отзыв.save()
        # и только теперь сохранён
        return redirect("один_отзыв", айди_отзыва=новый_отзыв.id)
        # Каждая функция должна закончится либо рендером страницы, либо перенаправлением на другую. redirect открывает страницу с тем name, который указан в urls
    контекст = {"форма": форма}
    return render(реквест, "редактировать_отзыв.html", контекст)

def редактировать_отзыв(реквест, айди_отзыва):
    отзыв = get_object_or_404(Отзыв, id=айди_отзыва)

    # Если поменялась картинка, старую надо удалить. Автоматически это не происходит. Значит сейчас запомним путь к файлу, а потом, если надо, удалим его.
    путь_к_картинке = отзыв.картинка.path

    if отзыв.автор != реквест.user:
        # Пользователь не залогинен или не является автором поста.
        return redirect("один_отзыв", айди_отзыва=айди_отзыва)
    
    if реквест.method == "GET":
        форма = ФормаОтзыва(instance=отзыв)
        # Этот отзыв уже существует, значит форму нужно заполнить его данные (текст, картинку, тег)
        контекст = {"форма": форма, "отзыв": отзыв}
        return render(реквест, "редактировать_отзыв.html", контекст)
    
    заполнения_форма = ФормаОтзыва(реквест.POST, реквест.FILES, instance=отзыв)
    if заполнения_форма.is_valid():
        if "картинка" in заполнения_форма.changed_data:
            # Если в заполненной форме в списке "заполненная информация" присутствует "картинка", значит старую надо удалить
            if os.path.exists(путь_к_картинке):
                # Если файл находится на компе
                os.remove(путь_к_картинке)
                # то удалим его

            # data - информация
            # date - дата
        заполнения_форма.save()
        return redirect("один_отзыв", айди_отзыва=айди_отзыва)
    контекст = {"форма": форма, "отзыв": отзыв}
    # Если пользователь попытался внести изменения в текст, но форма оказалась невалидна, то в переменной "заполненная форма", сохранились те изменения, которые он успел внести
    return render(реквест, "редактировать_отзыв.html", контекст)

def удалить_отзыв(реквест, айди_отзыва):
    отзыв = get_object_or_404(Отзыв, id=айди_отзыва)
    if отзыв.автор != реквест.user:
        return redirect("один_отзыв", айди_отзыва=айди_отзыва)
    
    путь_к_картинке = отзыв.картинка.path
    if os.path.exists(путь_к_картинке):
        os.remove(путь_к_картинке)
    отзыв.delete()
    return redirect("домашняя")
    
def редактировать_профиль(реквест):
    юзер = реквест.user
    if not юзер:
        return redirect("домашняя")
    if реквест.method == "POST" and "картинка" in реквест.FILES:
        # слово "картинка" совпадает с названием поля в модели Аватарка

        картинка = реквест.FILES.get("картинка")

        # если у пользователя уже привязана картинка, то БД не позволит создать вторую - потому что Юзер и Аватарка связаны один-к-одному